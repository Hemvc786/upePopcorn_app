import { useEffect, useState } from "react";
//RULE : NEVER UPDATE STATE IN RENDER LOGIC.

//fetch movie data at initial render.
const tempMovieData = [
  {
    imdbID: "tt1375666",
    Title: "Inception",
    Year: "2010",
    Poster:
      "https://m.media-amazon.com/images/M/MV5BMjAxMzY3NjcxNF5BMl5BanBnXkFtZTcwNTI5OTM0Mw@@._V1_SX300.jpg",
  },
  {
    imdbID: "tt0133093",
    Title: "The Matrix",
    Year: "1999",
    Poster:
      "https://m.media-amazon.com/images/M/MV5BNzQzOTk3OTAtNDQ0Zi00ZTVkLWI0MTEtMDllZjNkYzNjNTc4L2ltYWdlXkEyXkFqcGdeQXVyNjU0OTQ0OTY@._V1_SX300.jpg",
  },
  {
    imdbID: "tt6751668",
    Title: "Parasite",
    Year: "2019",
    Poster:
      "https://m.media-amazon.com/images/M/MV5BYWZjMjk3ZTItODQ2ZC00NTY5LWE0ZDYtZTI3MjcwN2Q5NTVkXkEyXkFqcGdeQXVyODk4OTc3MTY@._V1_SX300.jpg",
  },
];

const tempWatchedData = [
  {
    imdbID: "tt1375666",
    Title: "Inception",
    Year: "2010",
    Poster:
      "https://m.media-amazon.com/images/M/MV5BMjAxMzY3NjcxNF5BMl5BanBnXkFtZTcwNTI5OTM0Mw@@._V1_SX300.jpg",
    runtime: 148,
    imdbRating: 8.8,
    userRating: 10,
  },
  {
    imdbID: "tt0088763",
    Title: "Back to the Future",
    Year: "1985",
    Poster:
      "https://m.media-amazon.com/images/M/MV5BZmU0M2Y1OGUtZjIxNi00ZjBkLTg1MjgtOWIyNThiZWIwYjRiXkEyXkFqcGdeQXVyMTQxNzMzNDI@._V1_SX300.jpg",
    runtime: 116,
    imdbRating: 8.5,
    userRating: 9,
  },
];

const average = (arr) =>
  arr.reduce((acc, cur, i, arr) => acc + cur / arr.length, 0);

//variable declared outside comp function, Since this variable does not depend on anything inside the component.
const KEY = `bbfd0853`;

//structural component
export default function App() {
  const [query, setQuery] = useState("inception");
  const [movies, setMovies] = useState([]);
  const [watched, setWatched] = useState([]);
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState("");
  const [selectedId, setSelectedId] = useState("tt1375666");

  /*
  ///VIDEO: SYNCH MOVIES WITH QUERY DATA some trials:
  useEffect(function () {
    console.log("After Initial Render");
  }, []); //second due to order

  useEffect(function () {
    console.log("After every render");
  }); //third due to order

  useEffect(
    function () {
      console.log("D");
    },
    [query]
  );

  console.log("during the render"); //run during the render--executes First
*/

  //VIDEO: HOW TO NOT FETCH DATA
  //This data fetching introduces side effect in components render logic,i.e not allowed.
  //setting a state in render logic-----> will immediately cause component to re-rendered itself again.On re-render---->func is executed again-->fetch again--->setMovies again as well ---> also this whole thing happens over and over again----->Therefore Infinite loop of state setting and component re-rendering-->This is the reason why it is allowed to NOT set STATE in render LOGIC.
  //-------------------------------------------------------------------
  // fetch(`http://www.omdbapi.com/?apikey=${KEY}&s=interstellar`)
  //   .then((res) => res.json())
  //   .then((data) => setMovies(data.Search));
  //-------------------------------------------------------------------

  // fetch(`http://www.omdbapi.com/?apikey=${KEY}&s=interstellar`)
  //   .then((res) => res.json())
  //   .then((data) => console.log(data));//OK since here we are only logging to console

  // setWatched([]); //WILL CAUSE ERROR -> too many re-renders
  //we want to set movies here but w/o all the above problems
  //-----------------------------------------------------------------------------------------------------------

  // useEffect --> is used to register an effect.That effect is the function that contains the side effect that we want to register and register means code runs NOTTT when comoponent renders BUT code runs after when then component is painterd to the screen.

  /*
  WARNING::::::

  Effect callbacks are synchronous to prevent race conditions. Put the async function inside:

useEffect(() => {
  async function fetchData() {
    // You can await here
    const response = await MyAPI.getData(someId);
    // ...
  }
  fetchData();
}, [someId]); // Or [] if effect doesn't need props or state

//like below will give ERROR
 useEffect(async function () {
    fetch(`http://www.omdbapi.com/?apikey=${KEY}&s=interstellar`)
      .then((res) => res.json())
      .then((data) => setMovies(data.Search));
  }, []);
  */

  function handleSelectMovie(id) {
    setSelectedId(id);
  }

  function handleCloseMovie() {
    setSelectedId(null);
  }

  //VIDEO: SYNCH MOVIES WITH QUERY DATA::::::
  //now the useEffect hook is like a event handler which changes when the query state variable changes.
  useEffect(
    function () {
      async function fetchMovies() {
        try {
          setIsLoading(true);
          setError(""); //resetting error
          const res = await fetch(
            `http://www.omdbapi.com/?apikey=${KEY}&s=${query}`
          ); //effect is not yet synchronized with 'query' state variable,but effect not know that it should run each time query state changes so include query in depenedancy array .
          //fetch was successful but check if response is OK using below statement.
          if (!res.ok)
            throw new Error("Something went wrong with fetching movies");

          const data = await res.json();

          if (data.Response === "False") {
            throw new Error("Movie Not Found!");
          }
          setMovies(data.Search);
          setIsLoading(false);

          //console.log(movies); //will give an empty array, SINCE setting state is asynchronous after we instruct REACT to set state in above line of code that doesnt mean that it happens immediately, so here we have stale state therefore empty array.

          console.log(data.Search);
          console.log(data);
        } catch (err) {
          //  // if any .then above fails, this runs
          console.error(err.message);
          setError(err.message);
        } finally {
          setIsLoading(false);
        }
      }
      if (query.length < 3) {
        setMovies([]); //removing all movies from UI
        setError(""); //reset error to nothing
        return; //fetchMovies() will not even be called!!!!!
      }
      fetchMovies();
    },
    [query]
  );

  return (
    <>
      <NavBar>
        <Search query={query} setQuery={setQuery} />
        <NumResults movies={movies} />
      </NavBar>

      <Main>
        <Box>
          {/* {isLoading ? <Loader /> : <MovieList movies={movies} />} */}
          {isLoading && <Loader></Loader>}
          {!isLoading && !error && (
            <MovieList movies={movies} onSelectMovie={handleSelectMovie} />
          )}
          {error && <ErrorMessage message={error}></ErrorMessage>}
        </Box>

        <Box>
          <>
            {selectedId ? (
              <MovieDetails
                selectedId={selectedId}
                onCloseMovie={handleCloseMovie}
              />
            ) : (
              <>
                <WatchedSummary watched={watched} />
                <WatchedMovieList watched={watched} />
              </>
            )}
          </>
        </Box>
      </Main>
    </>
  );
}

function Loader() {
  return <p className="loader">Loading...</p>;
}
function ErrorMessage({ message }) {
  return (
    <p className="error">
      <span>‚õî</span>
      {message}
    </p>
  );
}

//structural component
function NavBar({ children }) {
  return (
    <nav className="nav-bar">
      <Logo />
      {children}
    </nav>
  );
}
//Presentational Component
function Logo() {
  return (
    <div className="logo">
      <span role="img">üçø</span>
      <h1>usePopcorn</h1>
    </div>
  );
}

//Stateful component
function Search({ query, setQuery }) {
  return (
    <input
      className="search"
      type="text"
      placeholder="Search movies..."
      value={query}
      onChange={(e) => setQuery(e.target.value)}
    />
  );
}

//Presentational Component
function NumResults({ movies }) {
  return (
    <p className="num-results">
      Found <strong>{movies.length}</strong> results
    </p>
  );
}

//structural component
function Main({ children }) {
  return <main className="main">{children}</main>;
}

//stateful component-->using children=representing COMPONENT COMPOSITION
function Box({ children }) {
  const [isOpen, setIsOpen] = useState(true);

  return (
    <div className="box">
      <button className="btn-toggle" onClick={() => setIsOpen((open) => !open)}>
        {isOpen ? "‚Äì" : "+"}
      </button>
      {isOpen && children}
    </div>
  );
}

//stateful component
function MovieList({ movies, onSelectMovie }) {
  return (
    <ul className="list list-movies">
      {movies?.map((movie) => (
        <Movie movie={movie} key={movie.imdbID} onSelectMovie={onSelectMovie} />
      ))}
    </ul>
  );
}

//stateless/presentational component
function Movie({ movie, onSelectMovie }) {
  return (
    <li onClick={() => onSelectMovie(movie.imdbID)}>
      <img src={movie.Poster} alt={`${movie.Title} poster`} />
      <h3>{movie.Title}</h3>
      <div>
        <p>
          <span>üóì</span>
          <span>{movie.Year}</span>
        </p>
      </div>
    </li>
  );
}

function MovieDetails({ selectedId, onCloseMovie }) {
  return (
    <div className="details">
      <button className="btn-back" onClick={onCloseMovie}>
        &larr;
      </button>
      {selectedId}
    </div>
  );
}

//stateless/presentational component
function WatchedSummary({ watched }) {
  const avgImdbRating = average(watched.map((movie) => movie.imdbRating));
  const avgUserRating = average(watched.map((movie) => movie.userRating));
  const avgRuntime = average(watched.map((movie) => movie.runtime));

  return (
    <div className="summary">
      <h2>Movies you watched</h2>
      <div>
        <p>
          <span>#Ô∏è‚É£</span>
          <span>{watched.length} movies</span>
        </p>
        <p>
          <span>‚≠êÔ∏è</span>
          <span>{avgImdbRating}</span>
        </p>
        <p>
          <span>üåü</span>
          <span>{avgUserRating}</span>
        </p>
        <p>
          <span>‚è≥</span>
          <span>{avgRuntime} min</span>
        </p>
      </div>
    </div>
  );
}

//stateless/presentational component
function WatchedMovieList({ watched }) {
  return (
    <ul className="list">
      {watched.map((movie) => (
        <WatchedMovie movie={movie} key={movie.imdbID} />
      ))}
    </ul>
  );
}

//stateless/presentational component
function WatchedMovie({ movie }) {
  return (
    <li key={movie.imdbID}>
      <img src={movie.Poster} alt={`${movie.Title} poster`} />
      <h3>{movie.Title}</h3>
      <div>
        <p>
          <span>‚≠êÔ∏è</span>
          <span>{movie.imdbRating}</span>
        </p>
        <p>
          <span>üåü</span>
          <span>{movie.userRating}</span>
        </p>
        <p>
          <span>‚è≥</span>
          <span>{movie.runtime} min</span>
        </p>
      </div>
    </li>
  );
}
